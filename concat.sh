#!/bin/bash

# 스크립트 이름: concat_with_path.sh
# 기능: 현재 디렉토리 및 모든 하위 디렉토리에서 '*.html' 및 '*.js' 파일들을 찾아
#       각 파일의 경로와 내용을 'combined_slides_with_path.txt' 파일 하나로 합칩니다.

OUTPUT_FILE="combined_slides_with_path.txt"
# 찾을 파일 패턴들 정의 (여기서는 HTML과 JavaScript)
# 필요에 따라 다른 패턴 추가 가능 (예: "*.css")
SOURCE_PATTERNS=(-name "*.html" -o -name "*.js")

echo "현재 디렉토리 및 하위 디렉토리의 '*.html', '*.js' 파일들을 '${OUTPUT_FILE}' 파일로 합치는 작업을 시작합니다..."
echo "각 파일 내용 앞에는 해당 파일의 상대 경로가 표시됩니다."
echo "주의: 파일 처리 순서는 find 명령에 따라 결정되며 보장되지 않습니다."

# 기존 출력 파일이 있다면 덮어쓰기 전에 삭제
rm -f "$OUTPUT_FILE"

# find 명령어를 사용하여 파일 목록을 찾고, -exec 옵션으로 sh -c를 실행하여
# 각 파일의 경로와 내용을 출력 파일에 추가합니다.
#
# find . : 현재 디렉토리(.)부터 시작하여 재귀적으로 검색
# -type f : 일반 파일만 대상으로 함 (디렉토리 등 제외)
# \( "${SOURCE_PATTERNS[@]}" \) : 위에서 정의한 패턴들을 OR 조건으로 묶음.
# -not -path "./${OUTPUT_FILE}" : 결과 파일 자체는 검색 대상에서 제외 (중요!)
# -exec sh -c '...' sh {} + :
#   - 찾은 파일들을 배치로 sh -c '...' 스크립트에 인수로 전달합니다. '+'는 효율성을 위함.
#   - '...' 안의 스크립트는 반복문을 사용하여 전달받은 각 파일($0, $1, ...)을 처리합니다.
#   - `sh` : sh -c '...' 다음에 오는 첫 번째 인수는 스크립트 내에서 $0 (스크립트 이름)으로 사용됩니다. 의미 있는 값을 넣을 필요는 없지만 관례상 'sh'나 '_'를 사용합니다.
#   - `{} +` : 찾은 파일 경로들이 스크립트의 인수($1, $2, ...)로 전달됩니다.
#   - 스크립트 내용:
#     - `for file do ... done`: find가 전달한 모든 파일 인수를 순회합니다 (`file` 변수에 할당됨).
#     - `echo "--- START FILE: $file ---"`: 파일 시작 구분자와 파일 경로를 출력합니다.
#     - `cat "$file"`: 해당 파일의 내용을 출력합니다.
#     - `echo ""; echo "--- END FILE: $file ---"; echo ""`: 파일 끝 구분자와 빈 줄을 추가하여 가독성을 높입니다.
# >> "$OUTPUT_FILE" : sh -c 스크립트의 표준 출력을 지정된 출력 파일에 *추가*합니다.
#                     find 명령 전체가 한 번 실행되므로, 실제로는 파일이 계속 추가되는 형태가 됩니다.
#                     주의: '>'를 사용하면 마지막 sh -c 호출만 파일에 쓰여질 수 있으므로 여기서는 >>가 더 적합해 보이지만,
#                     find -exec ... + > file 구조에서는 전체 출력이 리디렉션되므로 '>'가 맞습니다.
#                     헷갈림을 방지하기 위해 아래와 같이 수정합니다.

# 임시 파일을 사용하여 중간 결과를 저장하고 마지막에 합치는 방식 대신,
# find 명령의 전체 출력을 한 번에 리디렉션하는 것이 더 간단하고 효율적입니다.
find . -type f \( "${SOURCE_PATTERNS[@]}" \) -not -path "./${OUTPUT_FILE}" \
    -exec sh -c '
        # $0은 sh, $1부터 실제 파일 경로입니다.
        for file do
            # 파일이 실제로 존재하고 읽기 가능한지 확인 (find가 찾았으므로 보통은 존재)
            if [ -r "$file" ]; then
                echo "##################################################"
                echo "### FILE: $file"
                echo "##################################################"
                echo # 내용 시작 전 빈 줄
                cat "$file"
                echo # 내용 끝난 후 빈 줄
                echo # 구분선을 위한 추가 빈 줄
            else
                # 읽을 수 없는 파일이 있다면 표준 에러로 메시지 출력
                echo "경고: 파일을 읽을 수 없습니다: $file" >&2
            fi
        done
    ' sh {} + > "$OUTPUT_FILE" # 전체 find 명령의 표준 출력을 파일로 리디렉션

# 작업 완료 확인 (find 명령의 종료 코드 확인)
find_status=$? # 종료 코드를 변수에 저장

echo "파일 합치기 작업 시도 완료."

if [ $find_status -eq 0 ]; then
  # find 명령이 성공했더라도, 파일이 실제로 생성되었고 내용이 있는지 확인
  if [ -s "$OUTPUT_FILE" ]; then # -s 옵션: 파일이 존재하고 크기가 0보다 큰지 확인
    echo "성공: 모든 내용이 '${OUTPUT_FILE}' 파일에 저장되었습니다."
    echo "생성된 파일 크기: $(wc -c < "$OUTPUT_FILE") 바이트"
    echo "각 파일 내용은 '### FILE: 경로/파일명 ###' 구분자 아래에 저장되었습니다."
  elif [ -e "$OUTPUT_FILE" ]; then # 파일은 존재하지만 크기가 0인 경우 (매칭 파일이 없었거나 모두 비어있음)
    echo "성공 (주의): 매칭되는 '*.html' 또는 '*.js' 파일을 찾지 못했거나 모든 매칭 파일이 비어있어 '${OUTPUT_FILE}' 파일이 비어있습니다."
  else # find는 성공했지만 어떤 이유로 파일이 생성되지 않은 경우 (드물지만 가능, 예: 권한 문제)
    echo "오류: 파일 검색/합치기 명령은 성공했으나 결과 파일 '${OUTPUT_FILE}'이 생성되지 않았습니다."
    exit 1
  fi
else
  echo "오류: 파일 검색 또는 합치기 작업 중 문제가 발생했습니다 (종료 코드: ${find_status})."
  # 오류 발생 시 생성되었을 수 있는 불완전한 출력 파일 삭제
  rm -f "$OUTPUT_FILE"
  exit 1
fi

exit 0